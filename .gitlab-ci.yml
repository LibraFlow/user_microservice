stages:
- security_testing
- build
- test
- deploy-kubernetes

variables:
  # GIT_STRATEGY: clone
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  DOCKER_IMAGE: ${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/user-service/user-service:${CI_COMMIT_SHA}
  # Add NVD API key for better dependency check results
  NVD_API_KEY: ${NVD_API_KEY}
  KUBE_NAMESPACE: user-service
  KUBE_CLUSTER: ${GCP_PROJECT_ID}-gke
  # Add Docker network name for ZAP scanning
  DOCKER_NETWORK: zap-network
  # Add unique identifier for containers
  CONTAINER_ID: ${CI_PIPELINE_ID}
  # Add test port
  TEST_PORT: 8088

cache:
  paths:
  - user_service/app/.gradle/wrapper
  - user_service/app/.gradle/caches
  - user_service/app/dependency-check-data

static_analysis:
  stage: security_testing
  image: gradle:jdk17
  script:
    - cd user_service
    - gradle spotbugsMain spotbugsTest
    # Check if SpotBugs found any issues
    - |
      if (Test-Path "app/build/reports/spotbugs/main.xml") {
        $xml = [xml](Get-Content "app/build/reports/spotbugs/main.xml")
        $bugCount = $xml.SelectNodes("//BugInstance").Count
        if ($bugCount -gt 0) {
          Write-Host "::warning::SpotBugs found $bugCount potential issues. Please review the detailed report in the artifacts."
          Write-Host "::warning::To view the report, download the artifacts from this job or check the Code Quality report."
          # Exit with code 0 to allow the pipeline to continue, but with a warning
          exit 0
        }
      }
  artifacts:
    when: always
    expire_in: 1 week
    reports:
      codequality: user_service/app/build/reports/spotbugs/main.xml
    paths:
      - user_service/app/build/reports/spotbugs/
  allow_failure: true  # Allow the stage to fail without stopping the pipeline

# dependency_check:
#   stage: security_testing
#   script:
#     - powershell -Command "Invoke-WebRequest -Uri 'https://github.com/jeremylong/DependencyCheck/releases/download/v12.1.0/dependency-check-12.1.0-release.zip' -OutFile 'dependency-check.zip'"
#     - powershell -Command "Expand-Archive -Path 'dependency-check.zip' -DestinationPath 'dependency-check'"
#     - mkdir -p dependency-check-report
#     - powershell -Command "& 'dependency-check/dependency-check/bin/dependency-check.bat' --project 'user-service' --scan 'user_service/app' --format 'ALL' --out 'dependency-check-report'"
#   artifacts:
#     when: always
#     expire_in: 1 week
#     paths:
#       - dependency-check-report/
#     reports:
#       dependency_scanning: dependency-check-report/dependency-check-report.json
#   allow_failure: true

# owasp_cli_scan:
#   stage: security_testing
#   script:
#     - curl -LO https://github.com/jeremylong/DependencyCheck/releases/download/v12.1.0/dependency-check-12.1.0-release.zip
#     - powershell -Command "Expand-Archive dependency-check-12.1.0-release.zip -DestinationPath dc"
#     - mkdir -p owasp-report
#     - java -jar dc/dependency-check/dependency-check.jar --project "user-service" --scan "user_service/app" --format "ALL" --out "owasp-report" --nvdApiKey $env:NVD_API_KEY
#   artifacts:
#     when: always
#     expire_in: 1 week
#     paths:
#       - owasp-report/
#     reports:
#       dependency_scanning: owasp-report/dependency-check-report.json
#   allow_failure: true

zap_scan:
  stage: security_testing
  script:
    # Clean up any existing containers and networks
    - Write-Host "Cleaning up any existing containers and networks..."
    - |
      $ErrorActionPreference = 'SilentlyContinue'
      # Stop and remove any existing containers using port 8087 or 8088
      docker ps -a --filter "publish=8087" --filter "publish=8088" --format "{{.Names}}" | ForEach-Object {
        docker stop $_
        docker rm $_
      }
      docker network rm $DOCKER_NETWORK
      $ErrorActionPreference = 'Continue'
    # Create Docker network
    - Write-Host "Creating Docker network..."
    - docker network create $DOCKER_NETWORK
    # Build and start the user service
    - Write-Host "Building and starting user service..."
    - cd user_service
    - docker build -t user-service:test .
    - docker run -d --name user-service-${CONTAINER_ID} --network $DOCKER_NETWORK -p ${TEST_PORT}:8087 user-service:test
    # Wait for the service to be ready
    - Write-Host "Waiting for service to be ready..."
    - |
      $maxAttempts = 30
      $attempt = 0
      $serviceUp = $false
      
      while (-not $serviceUp -and $attempt -lt $maxAttempts) {
        $attempt++
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:${TEST_PORT}/actuator/health" -UseBasicParsing -TimeoutSec 2
          if ($response.Content -match '"status":"UP"') {
            Write-Host "Service is up!"
            $serviceUp = $true
            break
          }
        } catch {
          Write-Host "Waiting for service to start... ($attempt/$maxAttempts)"
          Start-Sleep -Seconds 2
        }
      }
      
      if (-not $serviceUp) {
        Write-Host "Service failed to start within 60 seconds"
        exit 1
      }
    # Run ZAP scan
    - Write-Host "Running ZAP scan..."
    - docker run --network $DOCKER_NETWORK -v "${PWD}:/zap/wrk" -t zaproxy/zap-stable zap-baseline.py -t http://user-service-${CONTAINER_ID}:8087 -r zap_report.html
  after_script:
    - Write-Host "Cleaning up resources..."
    - |
      $ErrorActionPreference = 'SilentlyContinue'
      docker stop user-service-${CONTAINER_ID}
      docker rm user-service-${CONTAINER_ID}
      docker network rm $DOCKER_NETWORK
      $ErrorActionPreference = 'Continue'
  artifacts:
    paths:
      - user_service/zap_report.html
    when: always
  allow_failure: true
  only:
    - merge_requests
    - main

build:
  stage: build
  image: gradle:jdk17
  script:
  - cd user_service
  - gradle build
  artifacts:
    paths:
    - user_service/app/build/libs/*.jar
  dependencies:
  - static_analysis
  # - dependency_check

test:
  stage: test
  image: gradle:jdk17
  script:
  - cd user_service
  - gradle test
  dependencies:
  - build

deploy-kubernetes:
  stage: deploy-kubernetes
  image: google/cloud-sdk:latest
  variables:
    DOCKER_HOST: npipe:////./pipe/docker_engine
  script:
    - if (!(Test-Path "//./pipe/docker_engine")) { throw "Docker Desktop is not running. Please start Docker Desktop and try again." }
    - $bytes = [System.Text.Encoding]::UTF8.GetBytes($GCP_K8S_SERVICE_ACCOUNT_KEY)
    - $encodedText = [Convert]::ToBase64String($bytes)
    - Set-Content -Path "$env:TEMP\k8s-key.json" -Value $GCP_K8S_SERVICE_ACCOUNT_KEY
    - gcloud auth activate-service-account --key-file="$env:TEMP\k8s-key.json"
    - gcloud config set project $GCP_PROJECT_ID
    - gcloud auth configure-docker ${GCP_REGION}-docker.pkg.dev
    - docker build -t $DOCKER_IMAGE ./user_service
    - docker push $DOCKER_IMAGE
    - gcloud container clusters get-credentials $KUBE_CLUSTER --region $GCP_REGION --project $GCP_PROJECT_ID
    - kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    # Create base64 encoded secrets
    - $datasourceUrl = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("jdbc:postgresql://${GCP_PROJECT_ID}:europe-west4:user-service-db/db4"))
    - $datasourceUsername = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("user6"))
    - $datasourcePassword = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("password6"))
    # Apply Kubernetes configurations
    - (Get-Content ./user_service/kubernetes/secrets.yaml) -replace '\${BASE64_ENCODED_DATASOURCE_URL}', $datasourceUrl -replace '\${BASE64_ENCODED_DATASOURCE_USERNAME}', $datasourceUsername -replace '\${BASE64_ENCODED_DATASOURCE_PASSWORD}', $datasourcePassword | kubectl apply -f - -n $KUBE_NAMESPACE
    # Apply service account and resources
    - kubectl apply -f ./user_service/kubernetes/service-account.yaml -n $KUBE_NAMESPACE
    - kubectl apply -f ./user_service/kubernetes/cloudsql-proxy.yaml -n $KUBE_NAMESPACE
    - kubectl apply -f ./user_service/kubernetes/resource-quota.yaml -n $KUBE_NAMESPACE
    # Replace variables in deployment.yaml and apply
    - (Get-Content ./user_service/kubernetes/deployment.yaml) -replace '\${GCP_REGION}', $GCP_REGION -replace '\${GCP_PROJECT_ID}', $GCP_PROJECT_ID -replace '\${CI_COMMIT_SHA}', $CI_COMMIT_SHA | kubectl apply -f - -n $KUBE_NAMESPACE
    - kubectl apply -f ./user_service/kubernetes/service.yaml -n $KUBE_NAMESPACE
  dependencies:
    - static_analysis
    - build
  only:
    - main