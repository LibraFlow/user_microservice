stages:
- security_testing
- build
- test
- deploy-kubernetes

variables:
  # GIT_STRATEGY: clone
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  DOCKER_IMAGE: ${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/user-service/user-service:${CI_COMMIT_SHA}
  # Add NVD API key for better dependency check results
  NVD_API_KEY: ${NVD_API_KEY}
  KUBE_NAMESPACE: user-service
  KUBE_CLUSTER: ${GCP_PROJECT_ID}-gke
  # Add Docker network name for ZAP scanning
  DOCKER_NETWORK: zap-network

cache:
  paths:
  - user_service/app/.gradle/wrapper
  - user_service/app/.gradle/caches
  - user_service/app/dependency-check-data

static_analysis:
  stage: security_testing
  image: gradle:jdk17
  script:
    - cd user_service
    - gradle spotbugsMain spotbugsTest
    # Check if SpotBugs found any issues
    - |
      if (Test-Path "app/build/reports/spotbugs/main.xml") {
        $xml = [xml](Get-Content "app/build/reports/spotbugs/main.xml")
        $bugCount = $xml.SelectNodes("//BugInstance").Count
        if ($bugCount -gt 0) {
          Write-Host "::warning::SpotBugs found $bugCount potential issues. Please review the detailed report in the artifacts."
          Write-Host "::warning::To view the report, download the artifacts from this job or check the Code Quality report."
          # Exit with code 0 to allow the pipeline to continue, but with a warning
          exit 0
        }
      }
  artifacts:
    when: always
    expire_in: 1 week
    reports:
      codequality: user_service/app/build/reports/spotbugs/main.xml
    paths:
      - user_service/app/build/reports/spotbugs/
  allow_failure: true  # Allow the stage to fail without stopping the pipeline

# dependency_check:
#   stage: security_testing
#   script:
#     - powershell -Command "Invoke-WebRequest -Uri 'https://github.com/jeremylong/DependencyCheck/releases/download/v12.1.0/dependency-check-12.1.0-release.zip' -OutFile 'dependency-check.zip'"
#     - powershell -Command "Expand-Archive -Path 'dependency-check.zip' -DestinationPath 'dependency-check'"
#     - mkdir -p dependency-check-report
#     - powershell -Command "& 'dependency-check/dependency-check/bin/dependency-check.bat' --project 'user-service' --scan 'user_service/app' --format 'ALL' --out 'dependency-check-report'"
#   artifacts:
#     when: always
#     expire_in: 1 week
#     paths:
#       - dependency-check-report/
#     reports:
#       dependency_scanning: dependency-check-report/dependency-check-report.json
#   allow_failure: true

# owasp_cli_scan:
#   stage: security_testing
#   script:
#     - curl -LO https://github.com/jeremylong/DependencyCheck/releases/download/v12.1.0/dependency-check-12.1.0-release.zip
#     - powershell -Command "Expand-Archive dependency-check-12.1.0-release.zip -DestinationPath dc"
#     - mkdir -p owasp-report
#     - java -jar dc/dependency-check/dependency-check.jar --project "user-service" --scan "user_service/app" --format "ALL" --out "owasp-report" --nvdApiKey $env:NVD_API_KEY
#   artifacts:
#     when: always
#     expire_in: 1 week
#     paths:
#       - owasp-report/
#     reports:
#       dependency_scanning: owasp-report/dependency-check-report.json
#   allow_failure: true

zap_scan:
  stage: security_testing
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "/certs/client"
  before_script:
    - apk add --no-cache docker-compose
    - docker network create $DOCKER_NETWORK
  script:
    # Build and start the user service
    - cd user_service
    - docker build -t user-service:test .
    - docker run -d --name user-service --network $DOCKER_NETWORK -p 8087:8087 user-service:test
    # Wait for the service to be ready
    - |
      for i in $(seq 1 30); do
        if curl -s http://localhost:8087/actuator/health | grep -q "UP"; then
          echo "Service is up!"
          break
        fi
        if [ $i -eq 30 ]; then
          echo "Service failed to start within 60 seconds"
          exit 1
        fi
        echo "Waiting for service to start... ($i/30)"
        sleep 2
      done
    # Run ZAP scan
    - docker run --network $DOCKER_NETWORK -v "${PWD}:/zap/wrk" -t zaproxy/zap-stable zap-baseline.py -t http://user-service:8087 -r zap_report.html
  after_script:
    - docker stop user-service || true
    - docker rm user-service || true
    - docker network rm $DOCKER_NETWORK || true
  artifacts:
    paths:
      - user_service/zap_report.html
    when: always
  allow_failure: true
  only:
    - merge_requests
    - main

build:
  stage: build
  image: gradle:jdk17
  script:
  - cd user_service
  - gradle build
  artifacts:
    paths:
    - user_service/app/build/libs/*.jar
  dependencies:
  - static_analysis
  # - dependency_check

test:
  stage: test
  image: gradle:jdk17
  script:
  - cd user_service
  - gradle test
  dependencies:
  - build

deploy-kubernetes:
  stage: deploy-kubernetes
  image: google/cloud-sdk:latest
  variables:
    DOCKER_HOST: npipe:////./pipe/docker_engine
  script:
    - if (!(Test-Path "//./pipe/docker_engine")) { throw "Docker Desktop is not running. Please start Docker Desktop and try again." }
    - $bytes = [System.Text.Encoding]::UTF8.GetBytes($GCP_K8S_SERVICE_ACCOUNT_KEY)
    - $encodedText = [Convert]::ToBase64String($bytes)
    - Set-Content -Path "$env:TEMP\k8s-key.json" -Value $GCP_K8S_SERVICE_ACCOUNT_KEY
    - gcloud auth activate-service-account --key-file="$env:TEMP\k8s-key.json"
    - gcloud config set project $GCP_PROJECT_ID
    - gcloud auth configure-docker ${GCP_REGION}-docker.pkg.dev
    - docker build -t $DOCKER_IMAGE ./user_service
    - docker push $DOCKER_IMAGE
    - gcloud container clusters get-credentials $KUBE_CLUSTER --region $GCP_REGION --project $GCP_PROJECT_ID
    - kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    # Create base64 encoded secrets
    - $datasourceUrl = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("jdbc:postgresql://${GCP_PROJECT_ID}:europe-west4:user-service-db/db4"))
    - $datasourceUsername = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("user6"))
    - $datasourcePassword = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("password6"))
    # Apply Kubernetes configurations
    - (Get-Content ./user_service/kubernetes/secrets.yaml) -replace '\${BASE64_ENCODED_DATASOURCE_URL}', $datasourceUrl -replace '\${BASE64_ENCODED_DATASOURCE_USERNAME}', $datasourceUsername -replace '\${BASE64_ENCODED_DATASOURCE_PASSWORD}', $datasourcePassword | kubectl apply -f - -n $KUBE_NAMESPACE
    # Apply service account and resources
    - kubectl apply -f ./user_service/kubernetes/service-account.yaml -n $KUBE_NAMESPACE
    - kubectl apply -f ./user_service/kubernetes/cloudsql-proxy.yaml -n $KUBE_NAMESPACE
    - kubectl apply -f ./user_service/kubernetes/resource-quota.yaml -n $KUBE_NAMESPACE
    # Replace variables in deployment.yaml and apply
    - (Get-Content ./user_service/kubernetes/deployment.yaml) -replace '\${GCP_REGION}', $GCP_REGION -replace '\${GCP_PROJECT_ID}', $GCP_PROJECT_ID -replace '\${CI_COMMIT_SHA}', $CI_COMMIT_SHA | kubectl apply -f - -n $KUBE_NAMESPACE
    - kubectl apply -f ./user_service/kubernetes/service.yaml -n $KUBE_NAMESPACE
  dependencies:
    - static_analysis
    - build
  only:
    - main